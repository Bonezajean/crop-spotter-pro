import { useState, useEffect, useRef, useMemo } from "react";
import { Card } from "@/components/ui/card";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Layers, Map as MapIcon } from "lucide-react";
import L from "leaflet";
import "leaflet/dist/leaflet.css";

interface FieldMapWithLayersProps {
  fieldId: string;
  showLayerControls?: boolean;
}

type LayerType = "none" | "ndvi" | "msavi" | "evi" | "ndwi" | "weed" | "pest";
type TerrainType = "osm" | "satellite" | "terrain" | "hybrid";

const terrainOptions: Record<TerrainType, { label: string; url: string; attribution: string; labelsUrl?: string }> = {
  osm: {
    label: "OpenStreetMap",
    url: "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
    attribution: '&copy; OpenStreetMap'
  },
  satellite: {
    label: "Satellite",
    url: "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
    attribution: '&copy; ESRI'
  },
  hybrid: {
    label: "Hybrid",
    url: "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
    labelsUrl: "https://server.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places/MapServer/tile/{z}/{y}/{x}",
    attribution: '&copy; ESRI'
  },
  terrain: {
    label: "Terrain",
    url: "https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png",
    attribution: '&copy; OpenTopoMap'
  }
};

const layerConfig: Record<LayerType, { label: string; description: string; colors: string[] }> = {
  none: {
    label: "No Layer",
    description: "Field boundary only",
    colors: []
  },
  ndvi: {
    label: "ðŸŒ± NDVI",
    description: "Vegetation Health Index",
    colors: ["#d73027", "#fc8d59", "#fee08b", "#d9ef8b", "#91cf60", "#1a9850"]
  },
  msavi: {
    label: "ðŸŒ¿ MSAVI",
    description: "Soil Adjusted Vegetation",
    colors: ["#8c510a", "#bf812d", "#dfc27d", "#80cdc1", "#35978f", "#01665e"]
  },
  evi: {
    label: "ðŸ€ EVI",
    description: "Enhanced Vegetation Index",
    colors: ["#762a83", "#af8dc3", "#e7d4e8", "#d9f0d3", "#7fbf7b", "#1b7837"]
  },
  ndwi: {
    label: "ðŸ’§ NDWI",
    description: "Water Index",
    colors: ["#a50026", "#f46d43", "#fdae61", "#abd9e9", "#74add1", "#313695"]
  },
  weed: {
    label: "ðŸŸ£ Weed",
    description: "Weed Detection",
    colors: ["#22c55e", "#84cc16", "#eab308", "#f97316", "#a855f7"]
  },
  pest: {
    label: "ðŸ”´ Pest",
    description: "Pest Detection",
    colors: ["#22c55e", "#84cc16", "#eab308", "#f97316", "#ef4444"]
  }
};

// Simulated field geometry (Rwanda - Gatsibo area)
const sampleFieldGeometry = {
  type: "FeatureCollection",
  features: [{
    type: "Feature",
    properties: { name: "Field Boundary" },
    geometry: {
      type: "Polygon",
      coordinates: [[
        [30.4550, -1.5900],
        [30.4600, -1.5900],
        [30.4600, -1.5950],
        [30.4550, -1.5950],
        [30.4550, -1.5900]
      ]]
    }
  }]
};

export const FieldMapWithLayers = ({ fieldId, showLayerControls = true }: FieldMapWithLayersProps) => {
  const [selectedLayer, setSelectedLayer] = useState<LayerType>("ndvi");
  const [terrain, setTerrain] = useState<TerrainType>("satellite");
  
  const mapContainerRef = useRef<HTMLDivElement>(null);
  const mapRef = useRef<L.Map | null>(null);
  const tileLayerRef = useRef<L.TileLayer | null>(null);
  const labelsLayerRef = useRef<L.TileLayer | null>(null);
  const boundaryLayerRef = useRef<L.GeoJSON | null>(null);
  const indexLayerRef = useRef<L.GeoJSON | null>(null);

  // Generate simulated index data
  const indexData = useMemo(() => {
    const bounds = {
      south: -1.5950,
      north: -1.5900,
      west: 30.4550,
      east: 30.4600
    };
    const gridSize = 0.0005;
    const data: Record<LayerType, any> = {} as any;

    (Object.keys(layerConfig) as LayerType[]).filter(k => k !== "none").forEach(index => {
      const features: any[] = [];
      
      for (let lat = bounds.south; lat < bounds.north; lat += gridSize) {
        for (let lng = bounds.west; lng < bounds.east; lng += gridSize) {
          // Generate spatially correlated values
          const baseValue = 0.5 + Math.sin(lat * 2000) * 0.25 + Math.cos(lng * 2000) * 0.2;
          const noise = (Math.random() - 0.5) * 0.2;
          const value = Math.max(0, Math.min(1, baseValue + noise));

          features.push({
            type: "Feature",
            properties: { value },
            geometry: {
              type: "Polygon",
              coordinates: [[
                [lng, lat],
                [lng + gridSize, lat],
                [lng + gridSize, lat + gridSize],
                [lng, lat + gridSize],
                [lng, lat]
              ]]
            }
          });
        }
      }

      data[index] = { type: "FeatureCollection", features };
    });

    return data;
  }, []);

  // Initialize map
  useEffect(() => {
    if (!mapContainerRef.current || mapRef.current) return;

    mapRef.current = L.map(mapContainerRef.current).setView([-1.5925, 30.4575], 15);
    
    const terrainConfig = terrainOptions[terrain];
    tileLayerRef.current = L.tileLayer(terrainConfig.url, {
      attribution: terrainConfig.attribution
    }).addTo(mapRef.current);

    // Add boundary layer
    boundaryLayerRef.current = L.geoJSON(sampleFieldGeometry as any, {
      style: {
        color: "#ffffff",
        weight: 3,
        fillColor: "transparent",
        fillOpacity: 0
      }
    }).addTo(mapRef.current);

    const bounds = boundaryLayerRef.current.getBounds();
    if (bounds.isValid()) {
      mapRef.current.fitBounds(bounds, { padding: [30, 30] });
    }

    return () => {
      if (mapRef.current) {
        mapRef.current.remove();
        mapRef.current = null;
      }
    };
  }, []);

  // Update terrain
  useEffect(() => {
    if (!mapRef.current) return;

    // Remove existing layers
    if (tileLayerRef.current) {
      mapRef.current.removeLayer(tileLayerRef.current);
    }
    if (labelsLayerRef.current) {
      mapRef.current.removeLayer(labelsLayerRef.current);
      labelsLayerRef.current = null;
    }

    const terrainConfig = terrainOptions[terrain];
    tileLayerRef.current = L.tileLayer(terrainConfig.url, {
      attribution: terrainConfig.attribution
    }).addTo(mapRef.current);

    // Add labels layer for hybrid terrain
    if (terrainConfig.labelsUrl) {
      labelsLayerRef.current = L.tileLayer(terrainConfig.labelsUrl, {
        attribution: ''
      }).addTo(mapRef.current);
    }

    // Ensure index layer is on top
    if (indexLayerRef.current) {
      indexLayerRef.current.bringToFront();
    }
    if (boundaryLayerRef.current) {
      boundaryLayerRef.current.bringToFront();
    }
  }, [terrain]);

  // Update index layer
  useEffect(() => {
    if (!mapRef.current) return;

    if (indexLayerRef.current) {
      mapRef.current.removeLayer(indexLayerRef.current);
      indexLayerRef.current = null;
    }

    if (selectedLayer === "none") return;

    const data = indexData[selectedLayer];
    if (!data) return;

    const colors = layerConfig[selectedLayer].colors;

    indexLayerRef.current = L.geoJSON(data, {
      style: (feature) => {
        const value = feature?.properties?.value || 0;
        const colorIndex = Math.min(Math.floor(value * colors.length), colors.length - 1);
        return {
          color: colors[colorIndex],
          weight: 0,
          fillColor: colors[colorIndex],
          fillOpacity: 0.75
        };
      }
    }).addTo(mapRef.current);

    // Keep boundary on top
    if (boundaryLayerRef.current) {
      boundaryLayerRef.current.bringToFront();
    }
  }, [selectedLayer, indexData]);

  const currentLayerConfig = layerConfig[selectedLayer];

  return (
    <div className="relative w-full h-[500px] rounded-lg overflow-hidden border border-border">
      {/* Leaflet Map */}
      <div ref={mapContainerRef} className="absolute inset-0 z-0" />

      {/* Controls Overlay */}
      {showLayerControls && (
        <>
          {/* Top Left - Terrain Selector */}
          <div className="absolute top-4 left-4 z-[1000]">
            <Card className="bg-card/95 backdrop-blur-sm border-border shadow-lg">
              <div className="px-3 py-2 flex items-center gap-2">
                <MapIcon className="h-4 w-4 text-muted-foreground" />
                <Select value={terrain} onValueChange={(v) => setTerrain(v as TerrainType)}>
                  <SelectTrigger className="w-[130px] h-8 bg-background/80">
                    <SelectValue />
                  </SelectTrigger>
                  <SelectContent>
                    {Object.entries(terrainOptions).map(([key, { label }]) => (
                      <SelectItem key={key} value={key}>{label}</SelectItem>
                    ))}
                  </SelectContent>
                </Select>
              </div>
            </Card>
          </div>

          {/* Bottom Center - Layer Selector */}
          <div className="absolute bottom-4 left-1/2 transform -translate-x-1/2 z-[1000]">
            <Card className="bg-card/95 backdrop-blur-sm border-border shadow-lg">
              <div className="px-4 py-3 flex items-center gap-3">
                <Layers className="h-4 w-4 text-muted-foreground" />
                <span className="text-sm font-medium">Index:</span>
                <Select value={selectedLayer} onValueChange={(v) => setSelectedLayer(v as LayerType)}>
                  <SelectTrigger className="w-[160px] h-9 bg-background/80">
                    <SelectValue />
                  </SelectTrigger>
                  <SelectContent>
                    {Object.entries(layerConfig).map(([key, { label }]) => (
                      <SelectItem key={key} value={key}>{label}</SelectItem>
                    ))}
                  </SelectContent>
                </Select>
              </div>
            </Card>
          </div>

          {/* Top Right - Legend */}
          {selectedLayer !== "none" && currentLayerConfig.colors.length > 0 && (
            <div className="absolute top-4 right-4 z-[1000]">
              <Card className="bg-card/95 backdrop-blur-sm border-border shadow-lg">
                <div className="px-4 py-3 space-y-2">
                  <p className="text-xs font-semibold text-muted-foreground uppercase tracking-wide">
                    {currentLayerConfig.description}
                  </p>
                  <div className="flex items-center gap-1">
                    <span className="text-xs text-muted-foreground">Low</span>
                    {currentLayerConfig.colors.map((color, i) => (
                      <div
                        key={i}
                        className="w-5 h-4 first:rounded-l last:rounded-r"
                        style={{ backgroundColor: color }}
                      />
                    ))}
                    <span className="text-xs text-muted-foreground">High</span>
                  </div>
                </div>
              </Card>
            </div>
          )}
        </>
      )}
    </div>
  );
};
